<!-- What is a tree. 

simple rules

directed graph
every node has two children 
left child is always less than its parent
right child is always greater than its parent

add inserts new node in right place
remove removes a node as long as with its branch
balance sorts the tree so its optional for searching
find searches the tree for a given value  -->

<script>
	function Node(data, left, right){
		this.data = data
		this.left = left || null
		this.right = right || null
	}

	function BinaryTree(){
		this.root = null;
		this.length = 0;
	}

	BinaryTree.prototype.add = function(data){
		var node = new Node(data);
		this.length += 1;
		if (this.root === null){
			return this.root = node;
		}
		var currentNode = this.root;
		var parentNode = null;
		while(currentNode) {
			parentNode = currentNode;
			if(data < currentNode.data){
				currentNode = currentNode.left
				if(currentNode === null){
					return parentNode.left = node;
				}
			} else {
				currentNode = currentNode.right
				if(currentNode === null){
					return parentNode.right = node;
				}
			}
		}
	}
	BinaryTree.prototype.search = function(data){
		var currentNode = this.root;
		var parentNode = null;
		if(currentNode.data == data){
			Nodes = {
				currentNode: currentNode,
				parentNode: parentNode
			}
			return Nodes
		}
		while(currentNode) {
			if(currentNode.data === data){
				Nodes = {
					currentNode: currentNode,
					parentNode: parentNode
				}
				return Nodes
			}
			parentNode = currentNode
			if(data < currentNode.data){
				if(currentNode.left === null){
					return false
				}
				currentNode = currentNode.left
			} else {
				if(currentNode.right === null){
					return false
				}
				currentNode = currentNode.right
			}
		}
	}
	BinaryTree.prototype.remove = function(data){
		var found = this.search(data);
		var childCount = 0;
		console.log(found)
		if(!found.currentNode){
			console.log('not found')
			return false
		} else {
			if(found.currentNode.left != null){
				childCount += 1
			}
			if(found.currentNode.right != null){
				childCount += 1
			}
			if(childCount === 0){
				if(found.currentNode.data < found.parentNode.data){
					found.parentNode.left = null;
				} else {
					found.parentNode.right = null;
				}
				found.currentNode = null;
				this.length -= 1;
			} else if(childCount === 1){
				if(found.currentNode.data < found.parentNode.data) {
					if(found.currentNode.left != null){
						found.parentNode.left = found.currentNode.left;
					} else {
						found.parentNode.left = found.currentNode.right
					}
				} else {
					if(found.currentNode.left != null){
						found.parentNode.right = found.currentNode.left;
					} else {
						found.parentNode.right = found.currentNode.right
					}
				}
				found.currentNode = null;
				this.length -= 1;
			} else {
				console.log('not there yet')
				// if(found.currentNode.data < found.parentNode.data) {
				// 	var replacement = found.currentNode.right
				// 	var new_placer = found.currentNode.left
				// 	var replacer = null
				// 	found.parentNode.left = replacement
				// 	if(replacement.left === null){
				// 		replacement.left = found.currentNode.left
				// 	} else {
				// 		while(replacement){
				// 			replacer = new_placer
				// 			if(new_placer < )
				// 		}
				// 	}
				// }
			}
		}
	}

	var tree = new BinaryTree()
	tree.add(12)
	tree.add(10)
	tree.add(4)
	tree.add(20)
	tree.add(23)
	console.log('before')
	console.log(tree)
	tree.remove(20)
	console.log("after")
	console.log(tree)
</script>
